#include "ros/ros.h"                          // ROS Default Header File
#include "ros_tutorials_topic/MsgTutorial.h"  // MsgTutorial Message File Header. The header file is automatically created when building the package.
#include <geometry_msgs/Twist.h>
#include "../include/gpio_ctrl.h"

#include "ros_tutorials_topic/Bumper.h"

#include <sys/time.h>
#include <unistd.h>
#include <time.h>
#include <math.h>
#include <stdlib.h>

#include <semaphore.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <fcntl.h>

#define CDR_MOTOR_TTY "/dev/ttyUSB0"

#define RIGHT_MOTOR 1
#define LEFT_MOTOR 2
#define RIGHT_MOTOR_DIR 12
#define LEFT_MOTOR_DIR 6

#define L_AC_PULS2 78 
#define L_AC_SIGN2 79
#define R_AC_PULS2 74
#define R_AC_SIGN2  75

#define LIGHT_RED 118
#define LIGHT_GREEN 117

#define INIT_PERIOD 10000

#define  ESS_KEY     9527
#define  ESS_SIZE    sizeof(struct epoll_sensor_info)
#define  KEY_NUM     9527
#define  MEM_SIZE    1024

struct left_encor_info{
	int encor_left;
};

struct right_encor_info{
	int encor_right;
};

struct epoll_sensor_info {
	struct left_encor_info left_encor_data;
	struct right_encor_info right_encor_data;
};
/////////////////////////////////////minseok//////////////////////////////
static pthread_t acmotor_thread;
static pthread_t pulse_thread;
static pthread_t encoder_thread;

float vel_linear,vel_angular;
int r_ro_val;
int l_ro_val;
float r_pulse;
float l_pulse;
float flag_stop;

void *do_acmotor(void *arg){
	while(1)
	{
		while(ros::ok){
			/*	flag_stop = fabs(vel_linear) + fabs(vel_angular);
				if(flag_stop < 0.001)
				{	
				l_pulse = 0;
				r_pulse = 0;
				}
				else
				*/
			{
				l_pulse = l_pulse + 2*(2*vel_linear - vel_angular*0.65);
				r_pulse = r_pulse + 2*(2*vel_linear + vel_angular*0.65);
			}
			//			ROS_INFO("l_ro_val=%d, r_ro_val=%d\n",l_ro_val, r_ro_val);
			usleep(1000);	//navigation
			//usleep(500);
		}
		sleep(1);
	}
}

void *do_cdr(void *arg){
	////////////////////////////////////////////////
}

void *do_pulse(void *arg){
	int lp;
	while(1)
	{
		while(ros::ok)
		{

			if((r_pulse != 0) || (l_pulse != 0))
			{
				if(l_pulse >= 1){
					l_pulse--;
					l_ro_val++;
				}
				else if(l_pulse <= -1){
					l_pulse++;
					l_ro_val--;
				}
				if(r_pulse >= 1){
					r_pulse--;
					r_ro_val++;
				}
				else if(r_pulse <= -1){
					r_pulse++;
					r_ro_val--;
				}
			}
			usleep(2);
		}
		sleep(1);
	}
	////////////////////////////////////////////////
}

void *do_encoder(void *arg)
{
	while(1)
	{
		int   epoll_shm_id;//minseok
		struct epoll_sensor_info *epoll_shm;//minseok
		struct encor_info *encor_data;//minseok

		struct left_encor_info *left_encor_data;//minseok
		struct right_encor_info *right_encor_data;//minseok

		int *left_sem_val,*right_sem_val, l_sem_val, r_sem_val;
		int *sem_arg;

		sem_t *left_sem;
		sem_t *right_sem;
		//	sem_unlink("left_sem");
		//	sem_unlink("right_sem");
		left_sem_val=&l_sem_val;
		right_sem_val=&r_sem_val;
		if((left_sem = sem_open("left_sem", O_CREAT, 0777, 0)) == NULL){
			perror("Sem Open Error");
		}

		if((right_sem = sem_open("right_sem", O_CREAT, 0777, 0)) == NULL){
			perror("Sem Open Error");
		}

		if (-1 == (epoll_shm_id = shmget((key_t)KEY_NUM, MEM_SIZE, IPC_CREAT|0666))){
			printf( "Create share mem fail\n");
		}

		if ((void *)-1 == ( epoll_shm = static_cast<epoll_sensor_info*>(shmat( epoll_shm_id, 0x0, 0)))){
			printf( "Insert share mem fail\n");
		}

		left_encor_data = &epoll_shm->left_encor_data;
		right_encor_data = &epoll_shm->right_encor_data;

		while(ros::ok)
		{
			sem_getvalue(left_sem,left_sem_val);

			if(l_sem_val < 1)
			{
				sem_post(left_sem);
				left_encor_data->encor_left = l_ro_val;
				l_ro_val=0;
			}
			sem_getvalue(right_sem,right_sem_val);
			if(r_sem_val < 1)
			{
				sem_post(right_sem);
				right_encor_data->encor_right = r_ro_val;
				r_ro_val=0;
			}
			usleep(10);	
		}
		sleep(1);
	}
	////////////////////////////////////////////////
}

int initAc(void)
{
	pthread_create(&acmotor_thread, 0, do_acmotor, 0);
	pthread_detach(acmotor_thread);
	pthread_create(&pulse_thread, 0, do_pulse, 0);
	pthread_detach(pulse_thread);
	pthread_create(&encoder_thread, 0, do_encoder, 0);
	pthread_detach(encoder_thread);
}

// Message callback function. This is a function is called when a topic
// message named 'ros_tutorial_msg' is received. As an input message,
// the 'MsgTutorial' message of the 'ros_tutorials_topic' package is received.
float ac_angular_bak = 0;
void msgCallback(const geometry_msgs::Twist& cmd_vel_msg)
{
	int fd;
	int l_speed, r_speed;
//	char cdr_lmotor_buf[64];
//	char cdr_rmotor_buf[64];
	char cdr_motor_buf[64];
	vel_linear = cmd_vel_msg.linear.x;
	vel_angular = cmd_vel_msg.angular.z;

	fd=open(CDR_MOTOR_TTY, O_RDWR);
	l_speed = 100*(vel_linear - vel_angular);
	r_speed = 100*(vel_linear + vel_angular);
	memset(cdr_motor_buf,0,sizeof(cdr_motor_buf));
//	memset(cdr_lmotor_buf,0,sizeof(cdr_lmotor_buf));
//	memset(cdr_rmotor_buf,0,sizeof(cdr_rmotor_buf));
/*
	if(abs(l_speed) < 0.001)
	{
		sprintf(cdr_lmotor_buf,"<0L0000>");
	}
	else if(l_speed > 0)
	{
		sprintf(cdr_lmotor_buf,"<0L1%03d>",l_speed+40);
	}
	else
	{
		sprintf(cdr_lmotor_buf,"<0L0%03d>",abs(l_speed)+40);
	}

	if(abs(r_speed) < 0.001)
	{
		sprintf(cdr_rmotor_buf,"<0R0000>");
	}
	else if(r_speed > 0)
	{
		sprintf(cdr_rmotor_buf,"<0R1%03d>",r_speed+40);
	}
	else
	{
		sprintf(cdr_rmotor_buf,"<0R0%03d>",abs(r_speed)+40);
	}
	*/
//	printf("l=%d %s, r=%d %s\n",l_speed,cdr_lmotor_buf, r_speed,cdr_rmotor_buf);

	int l_dir, r_dir;
	if(l_speed < 0)
	{
		l_dir = 0;
	}
	else 
	{
		l_dir = 1;
	}
	if(r_speed<0)
	{
		r_dir = 0;
	}
	else
	{
		r_dir = 1;
	}
	sprintf(cdr_motor_buf,"<M%01d%04d%,01d%04d,11>",l_dir,abs(l_speed),r_dir,abs(r_speed));
	printf("STR=-->%s<--\n",cdr_motor_buf);
	write(fd, cdr_motor_buf,strlen(cdr_motor_buf));
//	usleep(40000);
//	write(fd, cdr_rmotor_buf,strlen(cdr_rmotor_buf));

	close(fd);

	printf("linear = %.02f,angular = %.02f\n", vel_linear, vel_angular);
}
int main(int argc, char **argv)                         // Node Main Function
{
	initAc();	
	ros::init(argc, argv, "cdrmotor_subscriber");            // Initializes Node Name
	ros::NodeHandle nh;                                   // Node handle declaration for communication with ROS system
	//2020-12-02 JBK mpc_follow_mode Topic
	//ros::Subscriber ros_tutorial_sub = nh.subscribe("mobile_base/commands/velocity", 100, msgCallback);

	//2020-12-02 JBK mpc_navigaion Topic
	ros::Subscriber ros_tutorial_sub = nh.subscribe("cmd_vel", 1, msgCallback);

	ros::spin();

	return 0;
}
